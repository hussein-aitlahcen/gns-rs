<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Configuration options"><title>ESteamNetworkingConfigValue in gns_sys - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-de575e9a.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="gns_sys" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0-nightly (2fa8b11f0 2025-04-06)" data-channel="nightly" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc enum"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../gns_sys/index.html">gns_sys</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">ESteam<wbr>Networking<wbr>Config<wbr>Value</a></h2><h3><a href="#variants">Variants</a></h3><ul class="block variant"><li><a href="#variant.k_ESteamNetworkingConfigValue__Force32Bit" title="k_ESteamNetworkingConfigValue__Force32Bit">k_ESteamNetworkingConfigValue__Force32Bit</a></li><li><a href="#variant.k_ESteamNetworkingConfig_Callback_AuthStatusChanged" title="k_ESteamNetworkingConfig_Callback_AuthStatusChanged">k_ESteamNetworkingConfig_Callback_AuthStatusChanged</a></li><li><a href="#variant.k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged" title="k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged">k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged</a></li><li><a href="#variant.k_ESteamNetworkingConfig_Callback_CreateConnectionSignaling" title="k_ESteamNetworkingConfig_Callback_CreateConnectionSignaling">k_ESteamNetworkingConfig_Callback_CreateConnectionSignaling</a></li><li><a href="#variant.k_ESteamNetworkingConfig_Callback_FakeIPResult" title="k_ESteamNetworkingConfig_Callback_FakeIPResult">k_ESteamNetworkingConfig_Callback_FakeIPResult</a></li><li><a href="#variant.k_ESteamNetworkingConfig_Callback_MessagesSessionFailed" title="k_ESteamNetworkingConfig_Callback_MessagesSessionFailed">k_ESteamNetworkingConfig_Callback_MessagesSessionFailed</a></li><li><a href="#variant.k_ESteamNetworkingConfig_Callback_MessagesSessionRequest" title="k_ESteamNetworkingConfig_Callback_MessagesSessionRequest">k_ESteamNetworkingConfig_Callback_MessagesSessionRequest</a></li><li><a href="#variant.k_ESteamNetworkingConfig_Callback_RelayNetworkStatusChanged" title="k_ESteamNetworkingConfig_Callback_RelayNetworkStatusChanged">k_ESteamNetworkingConfig_Callback_RelayNetworkStatusChanged</a></li><li><a href="#variant.k_ESteamNetworkingConfig_ConnectionUserData" title="k_ESteamNetworkingConfig_ConnectionUserData">k_ESteamNetworkingConfig_ConnectionUserData</a></li><li><a href="#variant.k_ESteamNetworkingConfig_DELETED_EnumerateDevVars" title="k_ESteamNetworkingConfig_DELETED_EnumerateDevVars">k_ESteamNetworkingConfig_DELETED_EnumerateDevVars</a></li><li><a href="#variant.k_ESteamNetworkingConfig_DualWifi_Enable" title="k_ESteamNetworkingConfig_DualWifi_Enable">k_ESteamNetworkingConfig_DualWifi_Enable</a></li><li><a href="#variant.k_ESteamNetworkingConfig_ECN" title="k_ESteamNetworkingConfig_ECN">k_ESteamNetworkingConfig_ECN</a></li><li><a href="#variant.k_ESteamNetworkingConfig_EnableDiagnosticsUI" title="k_ESteamNetworkingConfig_EnableDiagnosticsUI">k_ESteamNetworkingConfig_EnableDiagnosticsUI</a></li><li><a href="#variant.k_ESteamNetworkingConfig_FakePacketDup_Recv" title="k_ESteamNetworkingConfig_FakePacketDup_Recv">k_ESteamNetworkingConfig_FakePacketDup_Recv</a></li><li><a href="#variant.k_ESteamNetworkingConfig_FakePacketDup_Send" title="k_ESteamNetworkingConfig_FakePacketDup_Send">k_ESteamNetworkingConfig_FakePacketDup_Send</a></li><li><a href="#variant.k_ESteamNetworkingConfig_FakePacketDup_TimeMax" title="k_ESteamNetworkingConfig_FakePacketDup_TimeMax">k_ESteamNetworkingConfig_FakePacketDup_TimeMax</a></li><li><a href="#variant.k_ESteamNetworkingConfig_FakePacketJitter_Recv_Avg" title="k_ESteamNetworkingConfig_FakePacketJitter_Recv_Avg">k_ESteamNetworkingConfig_FakePacketJitter_Recv_Avg</a></li><li><a href="#variant.k_ESteamNetworkingConfig_FakePacketJitter_Recv_Max" title="k_ESteamNetworkingConfig_FakePacketJitter_Recv_Max">k_ESteamNetworkingConfig_FakePacketJitter_Recv_Max</a></li><li><a href="#variant.k_ESteamNetworkingConfig_FakePacketJitter_Recv_Pct" title="k_ESteamNetworkingConfig_FakePacketJitter_Recv_Pct">k_ESteamNetworkingConfig_FakePacketJitter_Recv_Pct</a></li><li><a href="#variant.k_ESteamNetworkingConfig_FakePacketJitter_Send_Avg" title="k_ESteamNetworkingConfig_FakePacketJitter_Send_Avg">k_ESteamNetworkingConfig_FakePacketJitter_Send_Avg</a></li><li><a href="#variant.k_ESteamNetworkingConfig_FakePacketJitter_Send_Max" title="k_ESteamNetworkingConfig_FakePacketJitter_Send_Max">k_ESteamNetworkingConfig_FakePacketJitter_Send_Max</a></li><li><a href="#variant.k_ESteamNetworkingConfig_FakePacketJitter_Send_Pct" title="k_ESteamNetworkingConfig_FakePacketJitter_Send_Pct">k_ESteamNetworkingConfig_FakePacketJitter_Send_Pct</a></li><li><a href="#variant.k_ESteamNetworkingConfig_FakePacketLag_Recv" title="k_ESteamNetworkingConfig_FakePacketLag_Recv">k_ESteamNetworkingConfig_FakePacketLag_Recv</a></li><li><a href="#variant.k_ESteamNetworkingConfig_FakePacketLag_Send" title="k_ESteamNetworkingConfig_FakePacketLag_Send">k_ESteamNetworkingConfig_FakePacketLag_Send</a></li><li><a href="#variant.k_ESteamNetworkingConfig_FakePacketLoss_Recv" title="k_ESteamNetworkingConfig_FakePacketLoss_Recv">k_ESteamNetworkingConfig_FakePacketLoss_Recv</a></li><li><a href="#variant.k_ESteamNetworkingConfig_FakePacketLoss_Send" title="k_ESteamNetworkingConfig_FakePacketLoss_Send">k_ESteamNetworkingConfig_FakePacketLoss_Send</a></li><li><a href="#variant.k_ESteamNetworkingConfig_FakePacketReorder_Recv" title="k_ESteamNetworkingConfig_FakePacketReorder_Recv">k_ESteamNetworkingConfig_FakePacketReorder_Recv</a></li><li><a href="#variant.k_ESteamNetworkingConfig_FakePacketReorder_Send" title="k_ESteamNetworkingConfig_FakePacketReorder_Send">k_ESteamNetworkingConfig_FakePacketReorder_Send</a></li><li><a href="#variant.k_ESteamNetworkingConfig_FakePacketReorder_Time" title="k_ESteamNetworkingConfig_FakePacketReorder_Time">k_ESteamNetworkingConfig_FakePacketReorder_Time</a></li><li><a href="#variant.k_ESteamNetworkingConfig_FakeRateLimit_Recv_Burst" title="k_ESteamNetworkingConfig_FakeRateLimit_Recv_Burst">k_ESteamNetworkingConfig_FakeRateLimit_Recv_Burst</a></li><li><a href="#variant.k_ESteamNetworkingConfig_FakeRateLimit_Recv_Rate" title="k_ESteamNetworkingConfig_FakeRateLimit_Recv_Rate">k_ESteamNetworkingConfig_FakeRateLimit_Recv_Rate</a></li><li><a href="#variant.k_ESteamNetworkingConfig_FakeRateLimit_Send_Burst" title="k_ESteamNetworkingConfig_FakeRateLimit_Send_Burst">k_ESteamNetworkingConfig_FakeRateLimit_Send_Burst</a></li><li><a href="#variant.k_ESteamNetworkingConfig_FakeRateLimit_Send_Rate" title="k_ESteamNetworkingConfig_FakeRateLimit_Send_Rate">k_ESteamNetworkingConfig_FakeRateLimit_Send_Rate</a></li><li><a href="#variant.k_ESteamNetworkingConfig_IPLocalHost_AllowWithoutAuth" title="k_ESteamNetworkingConfig_IPLocalHost_AllowWithoutAuth">k_ESteamNetworkingConfig_IPLocalHost_AllowWithoutAuth</a></li><li><a href="#variant.k_ESteamNetworkingConfig_IP_AllowWithoutAuth" title="k_ESteamNetworkingConfig_IP_AllowWithoutAuth">k_ESteamNetworkingConfig_IP_AllowWithoutAuth</a></li><li><a href="#variant.k_ESteamNetworkingConfig_Invalid" title="k_ESteamNetworkingConfig_Invalid">k_ESteamNetworkingConfig_Invalid</a></li><li><a href="#variant.k_ESteamNetworkingConfig_LocalVirtualPort" title="k_ESteamNetworkingConfig_LocalVirtualPort">k_ESteamNetworkingConfig_LocalVirtualPort</a></li><li><a href="#variant.k_ESteamNetworkingConfig_LogLevel_AckRTT" title="k_ESteamNetworkingConfig_LogLevel_AckRTT">k_ESteamNetworkingConfig_LogLevel_AckRTT</a></li><li><a href="#variant.k_ESteamNetworkingConfig_LogLevel_Message" title="k_ESteamNetworkingConfig_LogLevel_Message">k_ESteamNetworkingConfig_LogLevel_Message</a></li><li><a href="#variant.k_ESteamNetworkingConfig_LogLevel_P2PRendezvous" title="k_ESteamNetworkingConfig_LogLevel_P2PRendezvous">k_ESteamNetworkingConfig_LogLevel_P2PRendezvous</a></li><li><a href="#variant.k_ESteamNetworkingConfig_LogLevel_PacketDecode" title="k_ESteamNetworkingConfig_LogLevel_PacketDecode">k_ESteamNetworkingConfig_LogLevel_PacketDecode</a></li><li><a href="#variant.k_ESteamNetworkingConfig_LogLevel_PacketGaps" title="k_ESteamNetworkingConfig_LogLevel_PacketGaps">k_ESteamNetworkingConfig_LogLevel_PacketGaps</a></li><li><a href="#variant.k_ESteamNetworkingConfig_LogLevel_SDRRelayPings" title="k_ESteamNetworkingConfig_LogLevel_SDRRelayPings">k_ESteamNetworkingConfig_LogLevel_SDRRelayPings</a></li><li><a href="#variant.k_ESteamNetworkingConfig_MTU_DataSize" title="k_ESteamNetworkingConfig_MTU_DataSize">k_ESteamNetworkingConfig_MTU_DataSize</a></li><li><a href="#variant.k_ESteamNetworkingConfig_MTU_PacketSize" title="k_ESteamNetworkingConfig_MTU_PacketSize">k_ESteamNetworkingConfig_MTU_PacketSize</a></li><li><a href="#variant.k_ESteamNetworkingConfig_NagleTime" title="k_ESteamNetworkingConfig_NagleTime">k_ESteamNetworkingConfig_NagleTime</a></li><li><a href="#variant.k_ESteamNetworkingConfig_OutOfOrderCorrectionWindowMicroseconds" title="k_ESteamNetworkingConfig_OutOfOrderCorrectionWindowMicroseconds">k_ESteamNetworkingConfig_OutOfOrderCorrectionWindowMicroseconds</a></li><li><a href="#variant.k_ESteamNetworkingConfig_P2P_STUN_ServerList" title="k_ESteamNetworkingConfig_P2P_STUN_ServerList">k_ESteamNetworkingConfig_P2P_STUN_ServerList</a></li><li><a href="#variant.k_ESteamNetworkingConfig_P2P_TURN_PassList" title="k_ESteamNetworkingConfig_P2P_TURN_PassList">k_ESteamNetworkingConfig_P2P_TURN_PassList</a></li><li><a href="#variant.k_ESteamNetworkingConfig_P2P_TURN_ServerList" title="k_ESteamNetworkingConfig_P2P_TURN_ServerList">k_ESteamNetworkingConfig_P2P_TURN_ServerList</a></li><li><a href="#variant.k_ESteamNetworkingConfig_P2P_TURN_UserList" title="k_ESteamNetworkingConfig_P2P_TURN_UserList">k_ESteamNetworkingConfig_P2P_TURN_UserList</a></li><li><a href="#variant.k_ESteamNetworkingConfig_P2P_Transport_ICE_Enable" title="k_ESteamNetworkingConfig_P2P_Transport_ICE_Enable">k_ESteamNetworkingConfig_P2P_Transport_ICE_Enable</a></li><li><a href="#variant.k_ESteamNetworkingConfig_P2P_Transport_ICE_Implementation" title="k_ESteamNetworkingConfig_P2P_Transport_ICE_Implementation">k_ESteamNetworkingConfig_P2P_Transport_ICE_Implementation</a></li><li><a href="#variant.k_ESteamNetworkingConfig_P2P_Transport_ICE_Penalty" title="k_ESteamNetworkingConfig_P2P_Transport_ICE_Penalty">k_ESteamNetworkingConfig_P2P_Transport_ICE_Penalty</a></li><li><a href="#variant.k_ESteamNetworkingConfig_P2P_Transport_SDR_Penalty" title="k_ESteamNetworkingConfig_P2P_Transport_SDR_Penalty">k_ESteamNetworkingConfig_P2P_Transport_SDR_Penalty</a></li><li><a href="#variant.k_ESteamNetworkingConfig_PacketTraceMaxBytes" title="k_ESteamNetworkingConfig_PacketTraceMaxBytes">k_ESteamNetworkingConfig_PacketTraceMaxBytes</a></li><li><a href="#variant.k_ESteamNetworkingConfig_RecvBufferMessages" title="k_ESteamNetworkingConfig_RecvBufferMessages">k_ESteamNetworkingConfig_RecvBufferMessages</a></li><li><a href="#variant.k_ESteamNetworkingConfig_RecvBufferSize" title="k_ESteamNetworkingConfig_RecvBufferSize">k_ESteamNetworkingConfig_RecvBufferSize</a></li><li><a href="#variant.k_ESteamNetworkingConfig_RecvMaxMessageSize" title="k_ESteamNetworkingConfig_RecvMaxMessageSize">k_ESteamNetworkingConfig_RecvMaxMessageSize</a></li><li><a href="#variant.k_ESteamNetworkingConfig_RecvMaxSegmentsPerPacket" title="k_ESteamNetworkingConfig_RecvMaxSegmentsPerPacket">k_ESteamNetworkingConfig_RecvMaxSegmentsPerPacket</a></li><li><a href="#variant.k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFail" title="k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFail">k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFail</a></li><li><a href="#variant.k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFailInitial" title="k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFailInitial">k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFailInitial</a></li><li><a href="#variant.k_ESteamNetworkingConfig_SDRClient_DevTicket" title="k_ESteamNetworkingConfig_SDRClient_DevTicket">k_ESteamNetworkingConfig_SDRClient_DevTicket</a></li><li><a href="#variant.k_ESteamNetworkingConfig_SDRClient_EnableTOSProbes" title="k_ESteamNetworkingConfig_SDRClient_EnableTOSProbes">k_ESteamNetworkingConfig_SDRClient_EnableTOSProbes</a></li><li><a href="#variant.k_ESteamNetworkingConfig_SDRClient_FakeClusterPing" title="k_ESteamNetworkingConfig_SDRClient_FakeClusterPing">k_ESteamNetworkingConfig_SDRClient_FakeClusterPing</a></li><li><a href="#variant.k_ESteamNetworkingConfig_SDRClient_ForceProxyAddr" title="k_ESteamNetworkingConfig_SDRClient_ForceProxyAddr">k_ESteamNetworkingConfig_SDRClient_ForceProxyAddr</a></li><li><a href="#variant.k_ESteamNetworkingConfig_SDRClient_ForceRelayCluster" title="k_ESteamNetworkingConfig_SDRClient_ForceRelayCluster">k_ESteamNetworkingConfig_SDRClient_ForceRelayCluster</a></li><li><a href="#variant.k_ESteamNetworkingConfig_SDRClient_LimitPingProbesToNearestN" title="k_ESteamNetworkingConfig_SDRClient_LimitPingProbesToNearestN">k_ESteamNetworkingConfig_SDRClient_LimitPingProbesToNearestN</a></li><li><a href="#variant.k_ESteamNetworkingConfig_SDRClient_MinPingsBeforePingAccurate" title="k_ESteamNetworkingConfig_SDRClient_MinPingsBeforePingAccurate">k_ESteamNetworkingConfig_SDRClient_MinPingsBeforePingAccurate</a></li><li><a href="#variant.k_ESteamNetworkingConfig_SDRClient_SingleSocket" title="k_ESteamNetworkingConfig_SDRClient_SingleSocket">k_ESteamNetworkingConfig_SDRClient_SingleSocket</a></li><li><a href="#variant.k_ESteamNetworkingConfig_SendBufferSize" title="k_ESteamNetworkingConfig_SendBufferSize">k_ESteamNetworkingConfig_SendBufferSize</a></li><li><a href="#variant.k_ESteamNetworkingConfig_SendRateMax" title="k_ESteamNetworkingConfig_SendRateMax">k_ESteamNetworkingConfig_SendRateMax</a></li><li><a href="#variant.k_ESteamNetworkingConfig_SendRateMin" title="k_ESteamNetworkingConfig_SendRateMin">k_ESteamNetworkingConfig_SendRateMin</a></li><li><a href="#variant.k_ESteamNetworkingConfig_SendTimeSincePreviousPacket" title="k_ESteamNetworkingConfig_SendTimeSincePreviousPacket">k_ESteamNetworkingConfig_SendTimeSincePreviousPacket</a></li><li><a href="#variant.k_ESteamNetworkingConfig_SymmetricConnect" title="k_ESteamNetworkingConfig_SymmetricConnect">k_ESteamNetworkingConfig_SymmetricConnect</a></li><li><a href="#variant.k_ESteamNetworkingConfig_TimeoutConnected" title="k_ESteamNetworkingConfig_TimeoutConnected">k_ESteamNetworkingConfig_TimeoutConnected</a></li><li><a href="#variant.k_ESteamNetworkingConfig_TimeoutInitial" title="k_ESteamNetworkingConfig_TimeoutInitial">k_ESteamNetworkingConfig_TimeoutInitial</a></li><li><a href="#variant.k_ESteamNetworkingConfig_Unencrypted" title="k_ESteamNetworkingConfig_Unencrypted">k_ESteamNetworkingConfig_Unencrypted</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-ESteamNetworkingConfigValue" title="Clone">Clone</a></li><li><a href="#impl-Copy-for-ESteamNetworkingConfigValue" title="Copy">Copy</a></li><li><a href="#impl-Debug-for-ESteamNetworkingConfigValue" title="Debug">Debug</a></li><li><a href="#impl-Eq-for-ESteamNetworkingConfigValue" title="Eq">Eq</a></li><li><a href="#impl-Hash-for-ESteamNetworkingConfigValue" title="Hash">Hash</a></li><li><a href="#impl-Ord-for-ESteamNetworkingConfigValue" title="Ord">Ord</a></li><li><a href="#impl-PartialEq-for-ESteamNetworkingConfigValue" title="PartialEq">PartialEq</a></li><li><a href="#impl-PartialOrd-for-ESteamNetworkingConfigValue" title="PartialOrd">PartialOrd</a></li><li><a href="#impl-StructuralPartialEq-for-ESteamNetworkingConfigValue" title="StructuralPartialEq">StructuralPartialEq</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-ESteamNetworkingConfigValue" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-ESteamNetworkingConfigValue" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-ESteamNetworkingConfigValue" title="Send">Send</a></li><li><a href="#impl-Sync-for-ESteamNetworkingConfigValue" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-ESteamNetworkingConfigValue" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-ESteamNetworkingConfigValue" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate gns_<wbr>sys</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">gns_sys</a></div><h1>Enum <span class="enum">ESteamNetworkingConfigValue</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/gns_sys/home/apk/github/gns-rs/target/debug/build/gns-sys-774006b2cb4e85e8/out/bindings.rs.html#1985-2136">Source</a> </span></div><pre class="rust item-decl"><code><div class="code-attribute">#[repr(u32)]</div>pub enum ESteamNetworkingConfigValue {
<details class="toggle type-contents-toggle"><summary class="hideme"><span>Show 78 variants</span></summary>    k_ESteamNetworkingConfig_Invalid = 0,
    k_ESteamNetworkingConfig_TimeoutInitial = 24,
    k_ESteamNetworkingConfig_TimeoutConnected = 25,
    k_ESteamNetworkingConfig_SendBufferSize = 9,
    k_ESteamNetworkingConfig_RecvBufferSize = 47,
    k_ESteamNetworkingConfig_RecvBufferMessages = 48,
    k_ESteamNetworkingConfig_RecvMaxMessageSize = 49,
    k_ESteamNetworkingConfig_RecvMaxSegmentsPerPacket = 50,
    k_ESteamNetworkingConfig_ConnectionUserData = 40,
    k_ESteamNetworkingConfig_SendRateMin = 10,
    k_ESteamNetworkingConfig_SendRateMax = 11,
    k_ESteamNetworkingConfig_NagleTime = 12,
    k_ESteamNetworkingConfig_IP_AllowWithoutAuth = 23,
    k_ESteamNetworkingConfig_IPLocalHost_AllowWithoutAuth = 52,
    k_ESteamNetworkingConfig_MTU_PacketSize = 32,
    k_ESteamNetworkingConfig_MTU_DataSize = 33,
    k_ESteamNetworkingConfig_Unencrypted = 34,
    k_ESteamNetworkingConfig_SymmetricConnect = 37,
    k_ESteamNetworkingConfig_LocalVirtualPort = 38,
    k_ESteamNetworkingConfig_DualWifi_Enable = 39,
    k_ESteamNetworkingConfig_EnableDiagnosticsUI = 46,
    k_ESteamNetworkingConfig_SendTimeSincePreviousPacket = 59,
    k_ESteamNetworkingConfig_FakePacketLoss_Send = 2,
    k_ESteamNetworkingConfig_FakePacketLoss_Recv = 3,
    k_ESteamNetworkingConfig_FakePacketLag_Send = 4,
    k_ESteamNetworkingConfig_FakePacketLag_Recv = 5,
    k_ESteamNetworkingConfig_FakePacketJitter_Send_Avg = 53,
    k_ESteamNetworkingConfig_FakePacketJitter_Send_Max = 54,
    k_ESteamNetworkingConfig_FakePacketJitter_Send_Pct = 55,
    k_ESteamNetworkingConfig_FakePacketJitter_Recv_Avg = 56,
    k_ESteamNetworkingConfig_FakePacketJitter_Recv_Max = 57,
    k_ESteamNetworkingConfig_FakePacketJitter_Recv_Pct = 58,
    k_ESteamNetworkingConfig_FakePacketReorder_Send = 6,
    k_ESteamNetworkingConfig_FakePacketReorder_Recv = 7,
    k_ESteamNetworkingConfig_FakePacketReorder_Time = 8,
    k_ESteamNetworkingConfig_FakePacketDup_Send = 26,
    k_ESteamNetworkingConfig_FakePacketDup_Recv = 27,
    k_ESteamNetworkingConfig_FakePacketDup_TimeMax = 28,
    k_ESteamNetworkingConfig_PacketTraceMaxBytes = 41,
    k_ESteamNetworkingConfig_FakeRateLimit_Send_Rate = 42,
    k_ESteamNetworkingConfig_FakeRateLimit_Send_Burst = 43,
    k_ESteamNetworkingConfig_FakeRateLimit_Recv_Rate = 44,
    k_ESteamNetworkingConfig_FakeRateLimit_Recv_Burst = 45,
    k_ESteamNetworkingConfig_OutOfOrderCorrectionWindowMicroseconds = 51,
    k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged = 201,
    k_ESteamNetworkingConfig_Callback_AuthStatusChanged = 202,
    k_ESteamNetworkingConfig_Callback_RelayNetworkStatusChanged = 203,
    k_ESteamNetworkingConfig_Callback_MessagesSessionRequest = 204,
    k_ESteamNetworkingConfig_Callback_MessagesSessionFailed = 205,
    k_ESteamNetworkingConfig_Callback_CreateConnectionSignaling = 206,
    k_ESteamNetworkingConfig_Callback_FakeIPResult = 207,
    k_ESteamNetworkingConfig_P2P_STUN_ServerList = 103,
    k_ESteamNetworkingConfig_P2P_Transport_ICE_Enable = 104,
    k_ESteamNetworkingConfig_P2P_Transport_ICE_Penalty = 105,
    k_ESteamNetworkingConfig_P2P_Transport_SDR_Penalty = 106,
    k_ESteamNetworkingConfig_P2P_TURN_ServerList = 107,
    k_ESteamNetworkingConfig_P2P_TURN_UserList = 108,
    k_ESteamNetworkingConfig_P2P_TURN_PassList = 109,
    k_ESteamNetworkingConfig_P2P_Transport_ICE_Implementation = 110,
    k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFailInitial = 19,
    k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFail = 20,
    k_ESteamNetworkingConfig_SDRClient_MinPingsBeforePingAccurate = 21,
    k_ESteamNetworkingConfig_SDRClient_SingleSocket = 22,
    k_ESteamNetworkingConfig_SDRClient_ForceRelayCluster = 29,
    k_ESteamNetworkingConfig_SDRClient_DevTicket = 30,
    k_ESteamNetworkingConfig_SDRClient_ForceProxyAddr = 31,
    k_ESteamNetworkingConfig_SDRClient_FakeClusterPing = 36,
    k_ESteamNetworkingConfig_SDRClient_LimitPingProbesToNearestN = 60,
    k_ESteamNetworkingConfig_LogLevel_AckRTT = 13,
    k_ESteamNetworkingConfig_LogLevel_PacketDecode = 14,
    k_ESteamNetworkingConfig_LogLevel_Message = 15,
    k_ESteamNetworkingConfig_LogLevel_PacketGaps = 16,
    k_ESteamNetworkingConfig_LogLevel_P2PRendezvous = 17,
    k_ESteamNetworkingConfig_LogLevel_SDRRelayPings = 18,
    k_ESteamNetworkingConfig_ECN = 999,
    k_ESteamNetworkingConfig_SDRClient_EnableTOSProbes = 998,
    k_ESteamNetworkingConfig_DELETED_EnumerateDevVars = 35,
    k_ESteamNetworkingConfigValue__Force32Bit = 2_147_483_647,
</details>}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Configuration options</p>
</div></details><h2 id="variants" class="variants section-header">Variants<a href="#variants" class="anchor">§</a></h2><div class="variants"><section id="variant.k_ESteamNetworkingConfig_Invalid" class="variant"><a href="#variant.k_ESteamNetworkingConfig_Invalid" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_Invalid = 0</h3></section><section id="variant.k_ESteamNetworkingConfig_TimeoutInitial" class="variant"><a href="#variant.k_ESteamNetworkingConfig_TimeoutInitial" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_TimeoutInitial = 24</h3></section><div class="docblock"><p>[connection int32] Timeout value (in ms) to use when first connecting</p>
</div><section id="variant.k_ESteamNetworkingConfig_TimeoutConnected" class="variant"><a href="#variant.k_ESteamNetworkingConfig_TimeoutConnected" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_TimeoutConnected = 25</h3></section><div class="docblock"><p>[connection int32] Timeout value (in ms) to use after connection is established</p>
</div><section id="variant.k_ESteamNetworkingConfig_SendBufferSize" class="variant"><a href="#variant.k_ESteamNetworkingConfig_SendBufferSize" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_SendBufferSize = 9</h3></section><div class="docblock"><p>[connection int32] Upper limit of buffered pending bytes to be sent,
if this is reached SendMessage will return k_EResultLimitExceeded
Default is 512k (524288 bytes)</p>
</div><section id="variant.k_ESteamNetworkingConfig_RecvBufferSize" class="variant"><a href="#variant.k_ESteamNetworkingConfig_RecvBufferSize" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_RecvBufferSize = 47</h3></section><div class="docblock"><p>[connection int32] Upper limit on total size (in bytes) of received messages
that will be buffered waiting to be processed by the application.  If this limit
is exceeded, packets will be dropped.  This is to protect us from a malicious
peer flooding us with messages faster than we can process them.</p>
<p>This must be bigger than k_ESteamNetworkingConfig_RecvMaxMessageSize</p>
</div><section id="variant.k_ESteamNetworkingConfig_RecvBufferMessages" class="variant"><a href="#variant.k_ESteamNetworkingConfig_RecvBufferMessages" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_RecvBufferMessages = 48</h3></section><div class="docblock"><p>[connection int32] Upper limit on the number of received messages that will
that will be buffered waiting to be processed by the application.  If this limit
is exceeded, packets will be dropped.  This is to protect us from a malicious
peer flooding us with messages faster than we can pull them off the wire.</p>
</div><section id="variant.k_ESteamNetworkingConfig_RecvMaxMessageSize" class="variant"><a href="#variant.k_ESteamNetworkingConfig_RecvMaxMessageSize" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_RecvMaxMessageSize = 49</h3></section><div class="docblock"><p>[connection int32] Maximum message size that we are willing to receive.
if a client attempts to send us a message larger than this, the connection
will be immediately closed.</p>
<p>Default is 512k (524288 bytes).  Note that the peer needs to be able to
send a message this big.  (See k_cbMaxSteamNetworkingSocketsMessageSizeSend.)</p>
</div><section id="variant.k_ESteamNetworkingConfig_RecvMaxSegmentsPerPacket" class="variant"><a href="#variant.k_ESteamNetworkingConfig_RecvMaxSegmentsPerPacket" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_RecvMaxSegmentsPerPacket = 50</h3></section><div class="docblock"><p>[connection int32] Max number of message segments that can be received
in a single UDP packet.  While decoding a packet, if the number of segments
exceeds this, we will abort further packet processing.</p>
<p>The default is effectively unlimited.  If you know that you very rarely
send small packets, you can protect yourself from malicious senders by
lowering this number.</p>
<p>In particular, if you are NOT using the reliability layer and are only using
SteamNetworkingSockets for datagram transport, setting this to a very low
number may be beneficial.  (We recommend a value of 2.)  Make sure your sender
disables Nagle!</p>
</div><section id="variant.k_ESteamNetworkingConfig_ConnectionUserData" class="variant"><a href="#variant.k_ESteamNetworkingConfig_ConnectionUserData" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_ConnectionUserData = 40</h3></section><div class="docblock"><p>[connection int64] Get/set userdata as a configuration option.
The default value is -1.   You may want to set the user data as
a config value, instead of using ISteamNetworkingSockets::SetConnectionUserData
in two specific instances:</p>
<ul>
<li>
<p>You wish to set the userdata atomically when creating
an outbound connection, so that the userdata is filled in properly
for any callbacks that happen.  However, note that this trick
only works for connections initiated locally!  For incoming
connections, multiple state transitions may happen and
callbacks be queued, before you are able to service the first
callback!  Be careful!</p>
</li>
<li>
<p>You can set the default userdata for all newly created connections
by setting this value at a higher level (e.g. on the listen
socket or at the global level.)  Then this default
value will be inherited when the connection is created.
This is useful in case -1 is a valid userdata value, and you
wish to use something else as the default value so you can
tell if it has been set or not.</p>
<p>HOWEVER: once a connection is created, the effective value is
then bound to the connection.  Unlike other connection options,
if you change it again at a higher level, the new value will not
be inherited by connections.</p>
</li>
</ul>
<p>Using the userdata field in callback structs is not advised because
of tricky race conditions.  Instead, you might try one of these methods:</p>
<ul>
<li>Use a separate map with the HSteamNetConnection as the key.</li>
<li>Fetch the userdata from the connection in your callback
using ISteamNetworkingSockets::GetConnectionUserData, to</li>
</ul>
</div><section id="variant.k_ESteamNetworkingConfig_SendRateMin" class="variant"><a href="#variant.k_ESteamNetworkingConfig_SendRateMin" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_SendRateMin = 10</h3></section><div class="docblock"><p>[connection int32] Minimum/maximum send rate clamp, in bytes/sec.
At the time of this writing these two options should always be set to
the same value, to manually configure a specific send rate.  The default
value is 256K.  Eventually we hope to have the library estimate the bandwidth
of the channel and set the send rate to that estimated bandwidth, and these
values will only set limits on that send rate.</p>
</div><section id="variant.k_ESteamNetworkingConfig_SendRateMax" class="variant"><a href="#variant.k_ESteamNetworkingConfig_SendRateMax" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_SendRateMax = 11</h3></section><div class="docblock"><p>[connection int32] Minimum/maximum send rate clamp, in bytes/sec.
At the time of this writing these two options should always be set to
the same value, to manually configure a specific send rate.  The default
value is 256K.  Eventually we hope to have the library estimate the bandwidth
of the channel and set the send rate to that estimated bandwidth, and these
values will only set limits on that send rate.</p>
</div><section id="variant.k_ESteamNetworkingConfig_NagleTime" class="variant"><a href="#variant.k_ESteamNetworkingConfig_NagleTime" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_NagleTime = 12</h3></section><div class="docblock"><p>[connection int32] Nagle time, in microseconds.  When SendMessage is called, if
the outgoing message is less than the size of the MTU, it will be
queued for a delay equal to the Nagle timer value.  This is to ensure
that if the application sends several small messages rapidly, they are
coalesced into a single packet.
See historical RFC 896.  Value is in microseconds.
Default is 5000us (5ms).</p>
</div><section id="variant.k_ESteamNetworkingConfig_IP_AllowWithoutAuth" class="variant"><a href="#variant.k_ESteamNetworkingConfig_IP_AllowWithoutAuth" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_IP_AllowWithoutAuth = 23</h3></section><div class="docblock"><p>[connection int32] Don’t automatically fail IP connections that don’t have
strong auth.  On clients, this means we will attempt the connection even if
we don’t know our identity or can’t get a cert.  On the server, it means that
we won’t automatically reject a connection due to a failure to authenticate.
(You can examine the incoming connection and decide whether to accept it.)</p>
<p>0: Don’t attempt or accept unauthorized connections
1: Attempt authorization when connecting, and allow unauthorized peers, but emit warnings
2: don’t attempt authentication, or complain if peer is unauthenticated</p>
<p>This is a dev configuration value, and you should not let users modify it in
production.</p>
</div><section id="variant.k_ESteamNetworkingConfig_IPLocalHost_AllowWithoutAuth" class="variant"><a href="#variant.k_ESteamNetworkingConfig_IPLocalHost_AllowWithoutAuth" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_IPLocalHost_AllowWithoutAuth = 52</h3></section><div class="docblock"><p>[connection int32] The same as IP_AllowWithoutAuth, but will only apply
for connections to/from localhost addresses.  Whichever value is larger
(more permissive) will be used.</p>
</div><section id="variant.k_ESteamNetworkingConfig_MTU_PacketSize" class="variant"><a href="#variant.k_ESteamNetworkingConfig_MTU_PacketSize" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_MTU_PacketSize = 32</h3></section><div class="docblock"><p>[connection int32] Do not send UDP packets with a payload of
larger than N bytes.  If you set this, k_ESteamNetworkingConfig_MTU_DataSize
is automatically adjusted</p>
</div><section id="variant.k_ESteamNetworkingConfig_MTU_DataSize" class="variant"><a href="#variant.k_ESteamNetworkingConfig_MTU_DataSize" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_MTU_DataSize = 33</h3></section><div class="docblock"><p>[connection int32] (read only) Maximum message size you can send that
will not fragment, based on k_ESteamNetworkingConfig_MTU_PacketSize</p>
</div><section id="variant.k_ESteamNetworkingConfig_Unencrypted" class="variant"><a href="#variant.k_ESteamNetworkingConfig_Unencrypted" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_Unencrypted = 34</h3></section><div class="docblock"><p>[connection int32] Allow unencrypted (and unauthenticated) communication.
0: Not allowed (the default)
1: Allowed, but prefer encrypted
2: Allowed, and preferred
3: Required.  (Fail the connection if the peer requires encryption.)</p>
<p>This is a dev configuration value, since its purpose is to disable encryption.
You should not let users modify it in production.  (But note that it requires
the peer to also modify their value in order for encryption to be disabled.)</p>
</div><section id="variant.k_ESteamNetworkingConfig_SymmetricConnect" class="variant"><a href="#variant.k_ESteamNetworkingConfig_SymmetricConnect" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_SymmetricConnect = 37</h3></section><div class="docblock"><p>[connection int32] Set this to 1 on outbound connections and listen sockets,
to enable “symmetric connect mode”, which is useful in the following
common peer-to-peer use case:</p>
<ul>
<li>The two peers are “equal” to each other.  (Neither is clearly the “client”
or “server”.)</li>
<li>Either peer may initiate the connection, and indeed they may do this
at the same time</li>
<li>The peers only desire a single connection to each other, and if both
peers initiate connections simultaneously, a protocol is needed for them
to resolve the conflict, so that we end up with a single connection.</li>
</ul>
<p>This use case is both common, and involves subtle race conditions and tricky
pitfalls, which is why the API has support for dealing with it.</p>
<p>If an incoming connection arrives on a listen socket or via custom signaling,
and the application has not attempted to make a matching outbound connection
in symmetric mode, then the incoming connection can be accepted as usual.
A “matching” connection means that the relevant endpoint information matches.
(At the time this comment is being written, this is only supported for P2P
connections, which means that the peer identities must match, and the virtual
port must match.  At a later time, symmetric mode may be supported for other
connection types.)</p>
<p>If connections are initiated by both peers simultaneously, race conditions
can arise, but fortunately, most of them are handled internally and do not
require any special awareness from the application.  However, there
is one important case that application code must be aware of:
If application code attempts an outbound connection using a ConnectXxx
function in symmetric mode, and a matching incoming connection is already
waiting on a listen socket, then instead of forming a new connection,
the ConnectXxx call will accept the existing incoming connection, and return
a connection handle to this accepted connection.
IMPORTANT: in this case, a SteamNetConnectionStatusChangedCallback_t
has probably <em>already</em> been posted to the queue for the incoming connection!
(Once callbacks are posted to the queue, they are not modified.)  It doesn’t
matter if the callback has not been consumed by the app.  Thus, application
code that makes use of symmetric connections must be aware that, when processing a
SteamNetConnectionStatusChangedCallback_t for an incoming connection, the
m_hConn may refer to a new connection that the app has has not
seen before (the usual case), but it may also refer to a connection that
has already been accepted implicitly through a call to Connect()!  In this
case, AcceptConnection() will return k_EResultDuplicateRequest.</p>
<p>Only one symmetric connection to a given peer (on a given virtual port)
may exist at any given time.  If client code attempts to create a connection,
and a (live) connection already exists on the local host, then either the
existing connection will be accepted as described above, or the attempt
to create a new connection will fail.  Furthermore, linger mode functionality
is not supported on symmetric connections.</p>
<p>A more complicated race condition can arise if both peers initiate a connection
at roughly the same time.  In this situation, each peer will receive an incoming
connection from the other peer, when the application code has already initiated
an outgoing connection to that peer.  The peers must resolve this conflict and
decide who is going to act as the “server” and who will act as the “client”.
Typically the application does not need to be aware of this case as it is handled
internally.  On both sides, the will observe their outbound connection being
“accepted”, although one of them one have been converted internally to act
as the “server”.</p>
<p>In general, symmetric mode should be all-or-nothing: do not mix symmetric
connections with a non-symmetric connection that it might possible “match”
with.  If you use symmetric mode on any connections, then both peers should
use it on all connections, and the corresponding listen socket, if any.  The
behaviour when symmetric and ordinary connections are mixed is not defined by
this API, and you should not rely on it.  (This advice only applies when connections
might possibly “match”.  For example, it’s OK to use all symmetric mode
connections on one virtual port, and all ordinary, non-symmetric connections
on a different virtual port, as there is no potential for ambiguity.)</p>
<p>When using the feature, you should set it in the following situations on
applicable objects:</p>
<ul>
<li>When creating an outbound connection using ConnectXxx function</li>
<li>When creating a listen socket.  (Note that this will automatically cause
any accepted connections to inherit the flag.)</li>
<li>When using custom signaling, before accepting an incoming connection.</li>
</ul>
<p>Setting the flag on listen socket and accepted connections will enable the
API to automatically deal with duplicate incoming connections, even if the
local host has not made any outbound requests.  (In general, such duplicate
requests from a peer are ignored internally and will not be visible to the
application code.  The previous connection must be closed or resolved first.)</p>
</div><section id="variant.k_ESteamNetworkingConfig_LocalVirtualPort" class="variant"><a href="#variant.k_ESteamNetworkingConfig_LocalVirtualPort" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_LocalVirtualPort = 38</h3></section><div class="docblock"><p>[connection int32] For connection types that use “virtual ports”, this can be used
to assign a local virtual port.  For incoming connections, this will always be the
virtual port of the listen socket (or the port requested by the remote host if custom
signaling is used and the connection is accepted), and cannot be changed.  For
connections initiated locally, the local virtual port will default to the same as the
requested remote virtual port, if you do not specify a different option when creating
the connection.  The local port is only relevant for symmetric connections, when
determining if two connections “match.”  In this case, if you need the local and remote
port to differ, you can set this value.</p>
<p>You can also read back this value on listen sockets.</p>
<p>This value should not be read or written in any other context.</p>
</div><section id="variant.k_ESteamNetworkingConfig_DualWifi_Enable" class="variant"><a href="#variant.k_ESteamNetworkingConfig_DualWifi_Enable" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_DualWifi_Enable = 39</h3></section><div class="docblock"><p>[connection int32] Enable Dual wifi band support for this connection
0 = no, 1 = yes, 2 = simulate it for debugging, even if dual wifi not available</p>
</div><section id="variant.k_ESteamNetworkingConfig_EnableDiagnosticsUI" class="variant"><a href="#variant.k_ESteamNetworkingConfig_EnableDiagnosticsUI" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_EnableDiagnosticsUI = 46</h3></section><div class="docblock"><p>[connection int32] True to enable diagnostics reporting through
generic platform UI.  (Only available on Steam.)</p>
</div><section id="variant.k_ESteamNetworkingConfig_SendTimeSincePreviousPacket" class="variant"><a href="#variant.k_ESteamNetworkingConfig_SendTimeSincePreviousPacket" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_SendTimeSincePreviousPacket = 59</h3></section><div class="docblock"><p>[connection int32] Send of time-since-previous-packet values in each UDP packet.
This add a small amount of packet overhead but allows for detailed jitter measurements
to be made by the receiver.</p>
<ul>
<li>0: disables the sending</li>
<li>1: enables sending</li>
<li>-1: (the default) Use the default for the connection type.  For plain UDP connections,
this is disabled, and for relayed connections, it is enabled.  Note that relays
always send the value.</li>
</ul>
</div><section id="variant.k_ESteamNetworkingConfig_FakePacketLoss_Send" class="variant"><a href="#variant.k_ESteamNetworkingConfig_FakePacketLoss_Send" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_FakePacketLoss_Send = 2</h3></section><div class="docblock"><p>[global float, 0–100] Randomly discard N pct of packets instead of sending/recv
This is a global option only, since it is applied at a low level
where we don’t have much context</p>
</div><section id="variant.k_ESteamNetworkingConfig_FakePacketLoss_Recv" class="variant"><a href="#variant.k_ESteamNetworkingConfig_FakePacketLoss_Recv" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_FakePacketLoss_Recv = 3</h3></section><div class="docblock"><p>[global float, 0–100] Randomly discard N pct of packets instead of sending/recv
This is a global option only, since it is applied at a low level
where we don’t have much context</p>
</div><section id="variant.k_ESteamNetworkingConfig_FakePacketLag_Send" class="variant"><a href="#variant.k_ESteamNetworkingConfig_FakePacketLag_Send" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_FakePacketLag_Send = 4</h3></section><div class="docblock"><p>[global int32].  Delay all outbound/inbound packets by N ms</p>
</div><section id="variant.k_ESteamNetworkingConfig_FakePacketLag_Recv" class="variant"><a href="#variant.k_ESteamNetworkingConfig_FakePacketLag_Recv" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_FakePacketLag_Recv = 5</h3></section><div class="docblock"><p>[global int32].  Delay all outbound/inbound packets by N ms</p>
</div><section id="variant.k_ESteamNetworkingConfig_FakePacketJitter_Send_Avg" class="variant"><a href="#variant.k_ESteamNetworkingConfig_FakePacketJitter_Send_Avg" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_FakePacketJitter_Send_Avg = 53</h3></section><div class="docblock"><p>Simulated jitter/clumping.</p>
<p>For each packet, a jitter value is determined (which may
be zero).  This amount is added as extra delay to the
packet.  When a subsequent packet is queued, it receives its
own random jitter amount from the current time.  if this would
result in the packets being delivered out of order, the later
packet queue time is adjusted to happen after the first packet.
Thus simulating jitter by itself will not reorder packets, but it
can “clump” them.</p>
<ul>
<li>Avg: A random jitter time is generated using an exponential
distribution using this value as the mean (ms).  The default
is zero, which disables random jitter.</li>
<li>Max: Limit the random jitter time to this value (ms).</li>
<li>Pct: odds (0-100) that a random jitter value for the packet
will be generated.  Otherwise, a jitter value of zero
is used, and the packet will only be delayed by the jitter
system if necessary to retain order, due to the jitter of a
previous packet.</li>
</ul>
<p>All values are [global float]</p>
<p>Fake jitter is simulated after fake lag, but before reordering.</p>
</div><section id="variant.k_ESteamNetworkingConfig_FakePacketJitter_Send_Max" class="variant"><a href="#variant.k_ESteamNetworkingConfig_FakePacketJitter_Send_Max" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_FakePacketJitter_Send_Max = 54</h3></section><div class="docblock"><p>Simulated jitter/clumping.</p>
<p>For each packet, a jitter value is determined (which may
be zero).  This amount is added as extra delay to the
packet.  When a subsequent packet is queued, it receives its
own random jitter amount from the current time.  if this would
result in the packets being delivered out of order, the later
packet queue time is adjusted to happen after the first packet.
Thus simulating jitter by itself will not reorder packets, but it
can “clump” them.</p>
<ul>
<li>Avg: A random jitter time is generated using an exponential
distribution using this value as the mean (ms).  The default
is zero, which disables random jitter.</li>
<li>Max: Limit the random jitter time to this value (ms).</li>
<li>Pct: odds (0-100) that a random jitter value for the packet
will be generated.  Otherwise, a jitter value of zero
is used, and the packet will only be delayed by the jitter
system if necessary to retain order, due to the jitter of a
previous packet.</li>
</ul>
<p>All values are [global float]</p>
<p>Fake jitter is simulated after fake lag, but before reordering.</p>
</div><section id="variant.k_ESteamNetworkingConfig_FakePacketJitter_Send_Pct" class="variant"><a href="#variant.k_ESteamNetworkingConfig_FakePacketJitter_Send_Pct" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_FakePacketJitter_Send_Pct = 55</h3></section><div class="docblock"><p>Simulated jitter/clumping.</p>
<p>For each packet, a jitter value is determined (which may
be zero).  This amount is added as extra delay to the
packet.  When a subsequent packet is queued, it receives its
own random jitter amount from the current time.  if this would
result in the packets being delivered out of order, the later
packet queue time is adjusted to happen after the first packet.
Thus simulating jitter by itself will not reorder packets, but it
can “clump” them.</p>
<ul>
<li>Avg: A random jitter time is generated using an exponential
distribution using this value as the mean (ms).  The default
is zero, which disables random jitter.</li>
<li>Max: Limit the random jitter time to this value (ms).</li>
<li>Pct: odds (0-100) that a random jitter value for the packet
will be generated.  Otherwise, a jitter value of zero
is used, and the packet will only be delayed by the jitter
system if necessary to retain order, due to the jitter of a
previous packet.</li>
</ul>
<p>All values are [global float]</p>
<p>Fake jitter is simulated after fake lag, but before reordering.</p>
</div><section id="variant.k_ESteamNetworkingConfig_FakePacketJitter_Recv_Avg" class="variant"><a href="#variant.k_ESteamNetworkingConfig_FakePacketJitter_Recv_Avg" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_FakePacketJitter_Recv_Avg = 56</h3></section><div class="docblock"><p>Simulated jitter/clumping.</p>
<p>For each packet, a jitter value is determined (which may
be zero).  This amount is added as extra delay to the
packet.  When a subsequent packet is queued, it receives its
own random jitter amount from the current time.  if this would
result in the packets being delivered out of order, the later
packet queue time is adjusted to happen after the first packet.
Thus simulating jitter by itself will not reorder packets, but it
can “clump” them.</p>
<ul>
<li>Avg: A random jitter time is generated using an exponential
distribution using this value as the mean (ms).  The default
is zero, which disables random jitter.</li>
<li>Max: Limit the random jitter time to this value (ms).</li>
<li>Pct: odds (0-100) that a random jitter value for the packet
will be generated.  Otherwise, a jitter value of zero
is used, and the packet will only be delayed by the jitter
system if necessary to retain order, due to the jitter of a
previous packet.</li>
</ul>
<p>All values are [global float]</p>
<p>Fake jitter is simulated after fake lag, but before reordering.</p>
</div><section id="variant.k_ESteamNetworkingConfig_FakePacketJitter_Recv_Max" class="variant"><a href="#variant.k_ESteamNetworkingConfig_FakePacketJitter_Recv_Max" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_FakePacketJitter_Recv_Max = 57</h3></section><div class="docblock"><p>Simulated jitter/clumping.</p>
<p>For each packet, a jitter value is determined (which may
be zero).  This amount is added as extra delay to the
packet.  When a subsequent packet is queued, it receives its
own random jitter amount from the current time.  if this would
result in the packets being delivered out of order, the later
packet queue time is adjusted to happen after the first packet.
Thus simulating jitter by itself will not reorder packets, but it
can “clump” them.</p>
<ul>
<li>Avg: A random jitter time is generated using an exponential
distribution using this value as the mean (ms).  The default
is zero, which disables random jitter.</li>
<li>Max: Limit the random jitter time to this value (ms).</li>
<li>Pct: odds (0-100) that a random jitter value for the packet
will be generated.  Otherwise, a jitter value of zero
is used, and the packet will only be delayed by the jitter
system if necessary to retain order, due to the jitter of a
previous packet.</li>
</ul>
<p>All values are [global float]</p>
<p>Fake jitter is simulated after fake lag, but before reordering.</p>
</div><section id="variant.k_ESteamNetworkingConfig_FakePacketJitter_Recv_Pct" class="variant"><a href="#variant.k_ESteamNetworkingConfig_FakePacketJitter_Recv_Pct" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_FakePacketJitter_Recv_Pct = 58</h3></section><div class="docblock"><p>Simulated jitter/clumping.</p>
<p>For each packet, a jitter value is determined (which may
be zero).  This amount is added as extra delay to the
packet.  When a subsequent packet is queued, it receives its
own random jitter amount from the current time.  if this would
result in the packets being delivered out of order, the later
packet queue time is adjusted to happen after the first packet.
Thus simulating jitter by itself will not reorder packets, but it
can “clump” them.</p>
<ul>
<li>Avg: A random jitter time is generated using an exponential
distribution using this value as the mean (ms).  The default
is zero, which disables random jitter.</li>
<li>Max: Limit the random jitter time to this value (ms).</li>
<li>Pct: odds (0-100) that a random jitter value for the packet
will be generated.  Otherwise, a jitter value of zero
is used, and the packet will only be delayed by the jitter
system if necessary to retain order, due to the jitter of a
previous packet.</li>
</ul>
<p>All values are [global float]</p>
<p>Fake jitter is simulated after fake lag, but before reordering.</p>
</div><section id="variant.k_ESteamNetworkingConfig_FakePacketReorder_Send" class="variant"><a href="#variant.k_ESteamNetworkingConfig_FakePacketReorder_Send" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_FakePacketReorder_Send = 6</h3></section><div class="docblock"><p>[global float] 0-100 Percentage of packets we will add additional
delay to.  If other packet(s) are sent/received within this delay
window (that doesn’t also randomly receive the same extra delay),
then the packets become reordered.</p>
<p>This mechanism is primarily intended to generate out-of-order
packets.  To simulate random jitter, use the FakePacketJitter.
Fake packet reordering is applied after fake lag and jitter</p>
</div><section id="variant.k_ESteamNetworkingConfig_FakePacketReorder_Recv" class="variant"><a href="#variant.k_ESteamNetworkingConfig_FakePacketReorder_Recv" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_FakePacketReorder_Recv = 7</h3></section><div class="docblock"><p>[global float] 0-100 Percentage of packets we will add additional
delay to.  If other packet(s) are sent/received within this delay
window (that doesn’t also randomly receive the same extra delay),
then the packets become reordered.</p>
<p>This mechanism is primarily intended to generate out-of-order
packets.  To simulate random jitter, use the FakePacketJitter.
Fake packet reordering is applied after fake lag and jitter</p>
</div><section id="variant.k_ESteamNetworkingConfig_FakePacketReorder_Time" class="variant"><a href="#variant.k_ESteamNetworkingConfig_FakePacketReorder_Time" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_FakePacketReorder_Time = 8</h3></section><div class="docblock"><p>[global int32] Extra delay, in ms, to apply to reordered
packets.  The same time value is used for sending and receiving.</p>
</div><section id="variant.k_ESteamNetworkingConfig_FakePacketDup_Send" class="variant"><a href="#variant.k_ESteamNetworkingConfig_FakePacketDup_Send" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_FakePacketDup_Send = 26</h3></section><div class="docblock"><p>[global float 0–100] Globally duplicate some percentage of packets.</p>
</div><section id="variant.k_ESteamNetworkingConfig_FakePacketDup_Recv" class="variant"><a href="#variant.k_ESteamNetworkingConfig_FakePacketDup_Recv" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_FakePacketDup_Recv = 27</h3></section><div class="docblock"><p>[global float 0–100] Globally duplicate some percentage of packets.</p>
</div><section id="variant.k_ESteamNetworkingConfig_FakePacketDup_TimeMax" class="variant"><a href="#variant.k_ESteamNetworkingConfig_FakePacketDup_TimeMax" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_FakePacketDup_TimeMax = 28</h3></section><div class="docblock"><p>[global int32] Amount of delay, in ms, to delay duplicated packets.
(We chose a random delay between 0 and this value)</p>
</div><section id="variant.k_ESteamNetworkingConfig_PacketTraceMaxBytes" class="variant"><a href="#variant.k_ESteamNetworkingConfig_PacketTraceMaxBytes" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_PacketTraceMaxBytes = 41</h3></section><div class="docblock"><p>[global int32] Trace every UDP packet, similar to Wireshark or tcpdump.
Value is max number of bytes to dump.  -1 disables tracing.</p>
</div><section id="variant.k_ESteamNetworkingConfig_FakeRateLimit_Send_Rate" class="variant"><a href="#variant.k_ESteamNetworkingConfig_FakeRateLimit_Send_Rate" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_FakeRateLimit_Send_Rate = 42</h3></section><section id="variant.k_ESteamNetworkingConfig_FakeRateLimit_Send_Burst" class="variant"><a href="#variant.k_ESteamNetworkingConfig_FakeRateLimit_Send_Burst" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_FakeRateLimit_Send_Burst = 43</h3></section><section id="variant.k_ESteamNetworkingConfig_FakeRateLimit_Recv_Rate" class="variant"><a href="#variant.k_ESteamNetworkingConfig_FakeRateLimit_Recv_Rate" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_FakeRateLimit_Recv_Rate = 44</h3></section><section id="variant.k_ESteamNetworkingConfig_FakeRateLimit_Recv_Burst" class="variant"><a href="#variant.k_ESteamNetworkingConfig_FakeRateLimit_Recv_Burst" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_FakeRateLimit_Recv_Burst = 45</h3></section><section id="variant.k_ESteamNetworkingConfig_OutOfOrderCorrectionWindowMicroseconds" class="variant"><a href="#variant.k_ESteamNetworkingConfig_OutOfOrderCorrectionWindowMicroseconds" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_OutOfOrderCorrectionWindowMicroseconds = 51</h3></section><section id="variant.k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged" class="variant"><a href="#variant.k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged = 201</h3></section><div class="docblock"><p>[connection FnSteamNetConnectionStatusChanged] Callback that will be invoked
when the state of a connection changes.</p>
<p>IMPORTANT: callbacks are dispatched to the handler that is in effect at the time
the event occurs, which might be in another thread.  For example, immediately after
creating a listen socket, you may receive an incoming connection.  And then immediately
after this, the remote host may close the connection.  All of this could happen
before the function to create the listen socket has returned.  For this reason,
callbacks usually must be in effect at the time of object creation.  This means
you should set them when you are creating the listen socket or connection, or have
them in effect so they will be inherited at the time of object creation.</p>
<p>For example:</p>
<p>exterm void MyStatusChangedFunc( SteamNetConnectionStatusChangedCallback_t *info );
SteamNetworkingConfigValue_t opt; opt.SetPtr( k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged, MyStatusChangedFunc );
SteamNetworkingIPAddr localAddress; localAddress.Clear();
HSteamListenSocket hListenSock = SteamNetworkingSockets()-&gt;CreateListenSocketIP( localAddress, 1, &amp;opt );</p>
<p>When accepting an incoming connection, there is no atomic way to switch the
callback.  However, if the connection is DOA, AcceptConnection() will fail, and
you can fetch the state of the connection at that time.</p>
<p>If all connections and listen sockets can use the same callback, the simplest
method is to set it globally before you create any listen sockets or connections.</p>
</div><section id="variant.k_ESteamNetworkingConfig_Callback_AuthStatusChanged" class="variant"><a href="#variant.k_ESteamNetworkingConfig_Callback_AuthStatusChanged" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_Callback_AuthStatusChanged = 202</h3></section><div class="docblock"><p>[global FnSteamNetAuthenticationStatusChanged] Callback that will be invoked
when our auth state changes.  If you use this, install the callback before creating
any connections or listen sockets, and don’t change it.
See: ISteamNetworkingUtils::SetGlobalCallback_SteamNetAuthenticationStatusChanged</p>
</div><section id="variant.k_ESteamNetworkingConfig_Callback_RelayNetworkStatusChanged" class="variant"><a href="#variant.k_ESteamNetworkingConfig_Callback_RelayNetworkStatusChanged" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_Callback_RelayNetworkStatusChanged = 203</h3></section><div class="docblock"><p>[global FnSteamRelayNetworkStatusChanged] Callback that will be invoked
when our auth state changes.  If you use this, install the callback before creating
any connections or listen sockets, and don’t change it.
See: ISteamNetworkingUtils::SetGlobalCallback_SteamRelayNetworkStatusChanged</p>
</div><section id="variant.k_ESteamNetworkingConfig_Callback_MessagesSessionRequest" class="variant"><a href="#variant.k_ESteamNetworkingConfig_Callback_MessagesSessionRequest" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_Callback_MessagesSessionRequest = 204</h3></section><div class="docblock"><p>[global FnSteamNetworkingMessagesSessionRequest] Callback that will be invoked
when a peer wants to initiate a SteamNetworkingMessagesSessionRequest.
See: ISteamNetworkingUtils::SetGlobalCallback_MessagesSessionRequest</p>
</div><section id="variant.k_ESteamNetworkingConfig_Callback_MessagesSessionFailed" class="variant"><a href="#variant.k_ESteamNetworkingConfig_Callback_MessagesSessionFailed" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_Callback_MessagesSessionFailed = 205</h3></section><div class="docblock"><p>[global FnSteamNetworkingMessagesSessionFailed] Callback that will be invoked
when a session you have initiated, or accepted either fails to connect, or loses
connection in some unexpected way.
See: ISteamNetworkingUtils::SetGlobalCallback_MessagesSessionFailed</p>
</div><section id="variant.k_ESteamNetworkingConfig_Callback_CreateConnectionSignaling" class="variant"><a href="#variant.k_ESteamNetworkingConfig_Callback_CreateConnectionSignaling" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_Callback_CreateConnectionSignaling = 206</h3></section><div class="docblock"><p>[global FnSteamNetworkingSocketsCreateConnectionSignaling] Callback that will
be invoked when we need to create a signaling object for a connection
initiated locally.  See: ISteamNetworkingSockets::ConnectP2P,
ISteamNetworkingMessages.</p>
</div><section id="variant.k_ESteamNetworkingConfig_Callback_FakeIPResult" class="variant"><a href="#variant.k_ESteamNetworkingConfig_Callback_FakeIPResult" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_Callback_FakeIPResult = 207</h3></section><div class="docblock"><p>[global FnSteamNetworkingFakeIPResult] Callback that’s invoked when
a FakeIP allocation finishes.  See: ISteamNetworkingSockets::BeginAsyncRequestFakeIP,
ISteamNetworkingUtils::SetGlobalCallback_FakeIPResult</p>
</div><section id="variant.k_ESteamNetworkingConfig_P2P_STUN_ServerList" class="variant"><a href="#variant.k_ESteamNetworkingConfig_P2P_STUN_ServerList" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_P2P_STUN_ServerList = 103</h3></section><div class="docblock"><p>[connection string] Comma-separated list of STUN servers that can be used
for NAT piercing.  If you set this to an empty string, NAT piercing will
not be attempted.  Also if “public” candidates are not allowed for
P2P_Transport_ICE_Enable, then this is ignored.</p>
</div><section id="variant.k_ESteamNetworkingConfig_P2P_Transport_ICE_Enable" class="variant"><a href="#variant.k_ESteamNetworkingConfig_P2P_Transport_ICE_Enable" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_P2P_Transport_ICE_Enable = 104</h3></section><div class="docblock"><p>[connection int32] What types of ICE candidates to share with the peer.
See k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_xxx values</p>
</div><section id="variant.k_ESteamNetworkingConfig_P2P_Transport_ICE_Penalty" class="variant"><a href="#variant.k_ESteamNetworkingConfig_P2P_Transport_ICE_Penalty" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_P2P_Transport_ICE_Penalty = 105</h3></section><div class="docblock"><p>[connection int32] When selecting P2P transport, add various
penalties to the scores for selected transports.  (Route selection
scores are on a scale of milliseconds.  The score begins with the
route ping time and is then adjusted.)</p>
</div><section id="variant.k_ESteamNetworkingConfig_P2P_Transport_SDR_Penalty" class="variant"><a href="#variant.k_ESteamNetworkingConfig_P2P_Transport_SDR_Penalty" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_P2P_Transport_SDR_Penalty = 106</h3></section><div class="docblock"><p>[connection int32] When selecting P2P transport, add various
penalties to the scores for selected transports.  (Route selection
scores are on a scale of milliseconds.  The score begins with the
route ping time and is then adjusted.)</p>
</div><section id="variant.k_ESteamNetworkingConfig_P2P_TURN_ServerList" class="variant"><a href="#variant.k_ESteamNetworkingConfig_P2P_TURN_ServerList" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_P2P_TURN_ServerList = 107</h3></section><div class="docblock"><p>[connection int32] When selecting P2P transport, add various
penalties to the scores for selected transports.  (Route selection
scores are on a scale of milliseconds.  The score begins with the
route ping time and is then adjusted.)</p>
</div><section id="variant.k_ESteamNetworkingConfig_P2P_TURN_UserList" class="variant"><a href="#variant.k_ESteamNetworkingConfig_P2P_TURN_UserList" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_P2P_TURN_UserList = 108</h3></section><div class="docblock"><p>[connection int32] When selecting P2P transport, add various
penalties to the scores for selected transports.  (Route selection
scores are on a scale of milliseconds.  The score begins with the
route ping time and is then adjusted.)</p>
</div><section id="variant.k_ESteamNetworkingConfig_P2P_TURN_PassList" class="variant"><a href="#variant.k_ESteamNetworkingConfig_P2P_TURN_PassList" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_P2P_TURN_PassList = 109</h3></section><div class="docblock"><p>[connection int32] When selecting P2P transport, add various
penalties to the scores for selected transports.  (Route selection
scores are on a scale of milliseconds.  The score begins with the
route ping time and is then adjusted.)</p>
</div><section id="variant.k_ESteamNetworkingConfig_P2P_Transport_ICE_Implementation" class="variant"><a href="#variant.k_ESteamNetworkingConfig_P2P_Transport_ICE_Implementation" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_P2P_Transport_ICE_Implementation = 110</h3></section><div class="docblock"><p>[connection int32] When selecting P2P transport, add various
penalties to the scores for selected transports.  (Route selection
scores are on a scale of milliseconds.  The score begins with the
route ping time and is then adjusted.)</p>
</div><section id="variant.k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFailInitial" class="variant"><a href="#variant.k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFailInitial" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFailInitial = 19</h3></section><div class="docblock"><p>[global int32] If the first N pings to a port all fail, mark that port as unavailable for
a while, and try a different one.  Some ISPs and routers may drop the first
packet, so setting this to 1 may greatly disrupt communications.</p>
</div><section id="variant.k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFail" class="variant"><a href="#variant.k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFail" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFail = 20</h3></section><div class="docblock"><p>[global int32] If N consecutive pings to a port fail, after having received successful
communication, mark that port as unavailable for a while, and try a
different one.</p>
</div><section id="variant.k_ESteamNetworkingConfig_SDRClient_MinPingsBeforePingAccurate" class="variant"><a href="#variant.k_ESteamNetworkingConfig_SDRClient_MinPingsBeforePingAccurate" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_SDRClient_MinPingsBeforePingAccurate = 21</h3></section><div class="docblock"><p>[global int32] Minimum number of lifetime pings we need to send, before we think our estimate
is solid.  The first ping to each cluster is very often delayed because of NAT,
routers not having the best route, etc.  Until we’ve sent a sufficient number
of pings, our estimate is often inaccurate.  Keep pinging until we get this
many pings.</p>
</div><section id="variant.k_ESteamNetworkingConfig_SDRClient_SingleSocket" class="variant"><a href="#variant.k_ESteamNetworkingConfig_SDRClient_SingleSocket" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_SDRClient_SingleSocket = 22</h3></section><div class="docblock"><p>[global int32] Set all steam datagram traffic to originate from the same
local port. By default, we open up a new UDP socket (on a different local
port) for each relay.  This is slightly less optimal, but it works around
some routers that don’t implement NAT properly.  If you have intermittent
problems talking to relays that might be NAT related, try toggling
this flag</p>
</div><section id="variant.k_ESteamNetworkingConfig_SDRClient_ForceRelayCluster" class="variant"><a href="#variant.k_ESteamNetworkingConfig_SDRClient_ForceRelayCluster" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_SDRClient_ForceRelayCluster = 29</h3></section><div class="docblock"><p>[global string] Code of relay cluster to force use.  If not empty, we will
only use relays in that cluster.  E.g. ‘iad’</p>
</div><section id="variant.k_ESteamNetworkingConfig_SDRClient_DevTicket" class="variant"><a href="#variant.k_ESteamNetworkingConfig_SDRClient_DevTicket" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_SDRClient_DevTicket = 30</h3></section><div class="docblock"><p>[connection string] For development, a base-64 encoded ticket generated
using the cert tool.  This can be used to connect to a gameserver via SDR
without a ticket generated using the game coordinator.  (You will still
need a key that is trusted for your app, however.)</p>
<p>This can also be passed using the SDR_DEVTICKET environment variable</p>
</div><section id="variant.k_ESteamNetworkingConfig_SDRClient_ForceProxyAddr" class="variant"><a href="#variant.k_ESteamNetworkingConfig_SDRClient_ForceProxyAddr" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_SDRClient_ForceProxyAddr = 31</h3></section><div class="docblock"><p>[global string] For debugging.  Override list of relays from the config with
this set (maybe just one).  Comma-separated list.</p>
</div><section id="variant.k_ESteamNetworkingConfig_SDRClient_FakeClusterPing" class="variant"><a href="#variant.k_ESteamNetworkingConfig_SDRClient_FakeClusterPing" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_SDRClient_FakeClusterPing = 36</h3></section><div class="docblock"><p>[global string] For debugging.  Force ping times to clusters to be the specified
values.  A comma separated list of <cluster>=<ms> values.  E.g. “sto=32,iad=100”</p>
<p>This is a dev configuration value, you probably should not let users modify it
in production.</p>
</div><section id="variant.k_ESteamNetworkingConfig_SDRClient_LimitPingProbesToNearestN" class="variant"><a href="#variant.k_ESteamNetworkingConfig_SDRClient_LimitPingProbesToNearestN" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_SDRClient_LimitPingProbesToNearestN = 60</h3></section><div class="docblock"><p>[global int32] When probing the SteamDatagram network, we limit exploration
to the closest N POPs, based on our current best approximated ping to that POP.</p>
</div><section id="variant.k_ESteamNetworkingConfig_LogLevel_AckRTT" class="variant"><a href="#variant.k_ESteamNetworkingConfig_LogLevel_AckRTT" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_LogLevel_AckRTT = 13</h3></section><div class="docblock"><p>[global int32] When probing the SteamDatagram network, we limit exploration
to the closest N POPs, based on our current best approximated ping to that POP.</p>
</div><section id="variant.k_ESteamNetworkingConfig_LogLevel_PacketDecode" class="variant"><a href="#variant.k_ESteamNetworkingConfig_LogLevel_PacketDecode" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_LogLevel_PacketDecode = 14</h3></section><div class="docblock"><p>[global int32] When probing the SteamDatagram network, we limit exploration
to the closest N POPs, based on our current best approximated ping to that POP.</p>
</div><section id="variant.k_ESteamNetworkingConfig_LogLevel_Message" class="variant"><a href="#variant.k_ESteamNetworkingConfig_LogLevel_Message" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_LogLevel_Message = 15</h3></section><div class="docblock"><p>[global int32] When probing the SteamDatagram network, we limit exploration
to the closest N POPs, based on our current best approximated ping to that POP.</p>
</div><section id="variant.k_ESteamNetworkingConfig_LogLevel_PacketGaps" class="variant"><a href="#variant.k_ESteamNetworkingConfig_LogLevel_PacketGaps" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_LogLevel_PacketGaps = 16</h3></section><div class="docblock"><p>[global int32] When probing the SteamDatagram network, we limit exploration
to the closest N POPs, based on our current best approximated ping to that POP.</p>
</div><section id="variant.k_ESteamNetworkingConfig_LogLevel_P2PRendezvous" class="variant"><a href="#variant.k_ESteamNetworkingConfig_LogLevel_P2PRendezvous" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_LogLevel_P2PRendezvous = 17</h3></section><div class="docblock"><p>[global int32] When probing the SteamDatagram network, we limit exploration
to the closest N POPs, based on our current best approximated ping to that POP.</p>
</div><section id="variant.k_ESteamNetworkingConfig_LogLevel_SDRRelayPings" class="variant"><a href="#variant.k_ESteamNetworkingConfig_LogLevel_SDRRelayPings" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_LogLevel_SDRRelayPings = 18</h3></section><div class="docblock"><p>[global int32] When probing the SteamDatagram network, we limit exploration
to the closest N POPs, based on our current best approximated ping to that POP.</p>
</div><section id="variant.k_ESteamNetworkingConfig_ECN" class="variant"><a href="#variant.k_ESteamNetworkingConfig_ECN" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_ECN = 999</h3></section><div class="docblock"><p>[global int32] When probing the SteamDatagram network, we limit exploration
to the closest N POPs, based on our current best approximated ping to that POP.</p>
</div><section id="variant.k_ESteamNetworkingConfig_SDRClient_EnableTOSProbes" class="variant"><a href="#variant.k_ESteamNetworkingConfig_SDRClient_EnableTOSProbes" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_SDRClient_EnableTOSProbes = 998</h3></section><div class="docblock"><p>[global int32] When probing the SteamDatagram network, we limit exploration
to the closest N POPs, based on our current best approximated ping to that POP.</p>
</div><section id="variant.k_ESteamNetworkingConfig_DELETED_EnumerateDevVars" class="variant"><a href="#variant.k_ESteamNetworkingConfig_DELETED_EnumerateDevVars" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfig_DELETED_EnumerateDevVars = 35</h3></section><div class="docblock"><p>[global int32] When probing the SteamDatagram network, we limit exploration
to the closest N POPs, based on our current best approximated ping to that POP.</p>
</div><section id="variant.k_ESteamNetworkingConfigValue__Force32Bit" class="variant"><a href="#variant.k_ESteamNetworkingConfigValue__Force32Bit" class="anchor">§</a><h3 class="code-header">k_ESteamNetworkingConfigValue__Force32Bit = 2_147_483_647</h3></section><div class="docblock"><p>[global int32] When probing the SteamDatagram network, we limit exploration
to the closest N POPs, based on our current best approximated ping to that POP.</p>
</div></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-ESteamNetworkingConfigValue" class="impl"><a class="src rightside" href="../src/gns_sys/home/apk/github/gns-rs/target/debug/build/gns-sys-774006b2cb4e85e8/out/bindings.rs.html#1984">Source</a><a href="#impl-Clone-for-ESteamNetworkingConfigValue" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="enum" href="enum.ESteamNetworkingConfigValue.html" title="enum gns_sys::ESteamNetworkingConfigValue">ESteamNetworkingConfigValue</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../src/gns_sys/home/apk/github/gns-rs/target/debug/build/gns-sys-774006b2cb4e85e8/out/bindings.rs.html#1984">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="enum" href="enum.ESteamNetworkingConfigValue.html" title="enum gns_sys::ESteamNetworkingConfigValue">ESteamNetworkingConfigValue</a></h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#174">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-ESteamNetworkingConfigValue" class="impl"><a class="src rightside" href="../src/gns_sys/home/apk/github/gns-rs/target/debug/build/gns-sys-774006b2cb4e85e8/out/bindings.rs.html#1984">Source</a><a href="#impl-Debug-for-ESteamNetworkingConfigValue" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="enum" href="enum.ESteamNetworkingConfigValue.html" title="enum gns_sys::ESteamNetworkingConfigValue">ESteamNetworkingConfigValue</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/gns_sys/home/apk/github/gns-rs/target/debug/build/gns-sys-774006b2cb4e85e8/out/bindings.rs.html#1984">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Hash-for-ESteamNetworkingConfigValue" class="impl"><a class="src rightside" href="../src/gns_sys/home/apk/github/gns-rs/target/debug/build/gns-sys-774006b2cb4e85e8/out/bindings.rs.html#1984">Source</a><a href="#impl-Hash-for-ESteamNetworkingConfigValue" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="enum" href="enum.ESteamNetworkingConfigValue.html" title="enum gns_sys::ESteamNetworkingConfigValue">ESteamNetworkingConfigValue</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl"><a class="src rightside" href="../src/gns_sys/home/apk/github/gns-rs/target/debug/build/gns-sys-774006b2cb4e85e8/out/bindings.rs.html#1984">Source</a><a href="#method.hash" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;__H: <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(&amp;self, state: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut __H</a>)</h4></section></summary><div class='docblock'>Feeds this value into the given <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/hash/mod.rs.html#235-237">Source</a></span><a href="#method.hash_slice" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice" class="fn">hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut H</a>)<div class="where">where
    H: <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Ord-for-ESteamNetworkingConfigValue" class="impl"><a class="src rightside" href="../src/gns_sys/home/apk/github/gns-rs/target/debug/build/gns-sys-774006b2cb4e85e8/out/bindings.rs.html#1984">Source</a><a href="#impl-Ord-for-ESteamNetworkingConfigValue" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="enum" href="enum.ESteamNetworkingConfigValue.html" title="enum gns_sys::ESteamNetworkingConfigValue">ESteamNetworkingConfigValue</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cmp" class="method trait-impl"><a class="src rightside" href="../src/gns_sys/home/apk/github/gns-rs/target/debug/build/gns-sys-774006b2cb4e85e8/out/bindings.rs.html#1984">Source</a><a href="#method.cmp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#tymethod.cmp" class="fn">cmp</a>(&amp;self, other: &amp;<a class="enum" href="enum.ESteamNetworkingConfigValue.html" title="enum gns_sys::ESteamNetworkingConfigValue">ESteamNetworkingConfigValue</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'>This method returns an <a href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#tymethod.cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.max" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1009-1011">Source</a></span><a href="#method.max" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.max" class="fn">max</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the maximum of two values. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.max">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.min" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1048-1050">Source</a></span><a href="#method.min" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.min" class="fn">min</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the minimum of two values. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.min">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clamp" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1074-1076">Source</a></span><a href="#method.clamp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.clamp" class="fn">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Restrict a value to a certain interval. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.clamp">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-ESteamNetworkingConfigValue" class="impl"><a class="src rightside" href="../src/gns_sys/home/apk/github/gns-rs/target/debug/build/gns-sys-774006b2cb4e85e8/out/bindings.rs.html#1984">Source</a><a href="#impl-PartialEq-for-ESteamNetworkingConfigValue" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="enum" href="enum.ESteamNetworkingConfigValue.html" title="enum gns_sys::ESteamNetworkingConfigValue">ESteamNetworkingConfigValue</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../src/gns_sys/home/apk/github/gns-rs/target/debug/build/gns-sys-774006b2cb4e85e8/out/bindings.rs.html#1984">Source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="enum" href="enum.ESteamNetworkingConfigValue.html" title="enum gns_sys::ESteamNetworkingConfigValue">ESteamNetworkingConfigValue</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#262">Source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd-for-ESteamNetworkingConfigValue" class="impl"><a class="src rightside" href="../src/gns_sys/home/apk/github/gns-rs/target/debug/build/gns-sys-774006b2cb4e85e8/out/bindings.rs.html#1984">Source</a><a href="#impl-PartialOrd-for-ESteamNetworkingConfigValue" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a> for <a class="enum" href="enum.ESteamNetworkingConfigValue.html" title="enum gns_sys::ESteamNetworkingConfigValue">ESteamNetworkingConfigValue</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl"><a class="src rightside" href="../src/gns_sys/home/apk/github/gns-rs/target/debug/build/gns-sys-774006b2cb4e85e8/out/bindings.rs.html#1984">Source</a><a href="#method.partial_cmp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="enum" href="enum.ESteamNetworkingConfigValue.html" title="enum gns_sys::ESteamNetworkingConfigValue">ESteamNetworkingConfigValue</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1382">Source</a></span><a href="#method.lt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1400">Source</a></span><a href="#method.le" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1418">Source</a></span><a href="#method.gt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1436">Source</a></span><a href="#method.ge" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><section id="impl-Copy-for-ESteamNetworkingConfigValue" class="impl"><a class="src rightside" href="../src/gns_sys/home/apk/github/gns-rs/target/debug/build/gns-sys-774006b2cb4e85e8/out/bindings.rs.html#1984">Source</a><a href="#impl-Copy-for-ESteamNetworkingConfigValue" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="enum" href="enum.ESteamNetworkingConfigValue.html" title="enum gns_sys::ESteamNetworkingConfigValue">ESteamNetworkingConfigValue</a></h3></section><section id="impl-Eq-for-ESteamNetworkingConfigValue" class="impl"><a class="src rightside" href="../src/gns_sys/home/apk/github/gns-rs/target/debug/build/gns-sys-774006b2cb4e85e8/out/bindings.rs.html#1984">Source</a><a href="#impl-Eq-for-ESteamNetworkingConfigValue" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="enum" href="enum.ESteamNetworkingConfigValue.html" title="enum gns_sys::ESteamNetworkingConfigValue">ESteamNetworkingConfigValue</a></h3></section><section id="impl-StructuralPartialEq-for-ESteamNetworkingConfigValue" class="impl"><a class="src rightside" href="../src/gns_sys/home/apk/github/gns-rs/target/debug/build/gns-sys-774006b2cb4e85e8/out/bindings.rs.html#1984">Source</a><a href="#impl-StructuralPartialEq-for-ESteamNetworkingConfigValue" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.StructuralPartialEq.html" title="trait core::marker::StructuralPartialEq">StructuralPartialEq</a> for <a class="enum" href="enum.ESteamNetworkingConfigValue.html" title="enum gns_sys::ESteamNetworkingConfigValue">ESteamNetworkingConfigValue</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-ESteamNetworkingConfigValue" class="impl"><a href="#impl-Freeze-for-ESteamNetworkingConfigValue" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="enum" href="enum.ESteamNetworkingConfigValue.html" title="enum gns_sys::ESteamNetworkingConfigValue">ESteamNetworkingConfigValue</a></h3></section><section id="impl-RefUnwindSafe-for-ESteamNetworkingConfigValue" class="impl"><a href="#impl-RefUnwindSafe-for-ESteamNetworkingConfigValue" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="enum" href="enum.ESteamNetworkingConfigValue.html" title="enum gns_sys::ESteamNetworkingConfigValue">ESteamNetworkingConfigValue</a></h3></section><section id="impl-Send-for-ESteamNetworkingConfigValue" class="impl"><a href="#impl-Send-for-ESteamNetworkingConfigValue" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="enum" href="enum.ESteamNetworkingConfigValue.html" title="enum gns_sys::ESteamNetworkingConfigValue">ESteamNetworkingConfigValue</a></h3></section><section id="impl-Sync-for-ESteamNetworkingConfigValue" class="impl"><a href="#impl-Sync-for-ESteamNetworkingConfigValue" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="enum" href="enum.ESteamNetworkingConfigValue.html" title="enum gns_sys::ESteamNetworkingConfigValue">ESteamNetworkingConfigValue</a></h3></section><section id="impl-Unpin-for-ESteamNetworkingConfigValue" class="impl"><a href="#impl-Unpin-for-ESteamNetworkingConfigValue" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="enum" href="enum.ESteamNetworkingConfigValue.html" title="enum gns_sys::ESteamNetworkingConfigValue">ESteamNetworkingConfigValue</a></h3></section><section id="impl-UnwindSafe-for-ESteamNetworkingConfigValue" class="impl"><a href="#impl-UnwindSafe-for-ESteamNetworkingConfigValue" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="enum" href="enum.ESteamNetworkingConfigValue.html" title="enum gns_sys::ESteamNetworkingConfigValue">ESteamNetworkingConfigValue</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#441">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#443">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#767">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#770">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#750-752">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#760">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#82-84">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#86">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#87">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#91">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#806-808">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#810">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#813">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#791-793">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#795">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#798">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>